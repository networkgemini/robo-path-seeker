
#!/usr/bin/env python3

"""
Robot Controller for Dijkstra Path Planning

This module implements the controller that makes the robot follow the path
generated by the Dijkstra algorithm. It translates the path into motion
commands for the robot.

Features:
1. Path following with proportional control
2. Simple obstacle avoidance
3. Goal-reached detection
4. Path replanning when necessary

Requirements:
- ROS2 Humble
- Python 3.8+
"""

import rclpy
from rclpy.node import Node
from nav_msgs.msg import Path, OccupancyGrid
from geometry_msgs.msg import Twist, PoseStamped, Point
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
import numpy as np
import math


class RobotController(Node):
    """Controller for the robot to follow Dijkstra-planned paths"""
    
    def __init__(self):
        super().__init__('robot_controller')
        
        # Parameters
        self.declare_parameter('max_linear_speed', 0.2)      # m/s
        self.declare_parameter('max_angular_speed', 0.5)     # rad/s
        self.declare_parameter('goal_tolerance', 0.1)        # m
        self.declare_parameter('path_lookahead', 5)          # points ahead to target
        self.declare_parameter('control_frequency', 10.0)    # Hz
        
        # Get parameters
        self.max_linear_speed = self.get_parameter('max_linear_speed').value
        self.max_angular_speed = self.get_parameter('max_angular_speed').value
        self.goal_tolerance = self.get_parameter('goal_tolerance').value
        self.path_lookahead = self.get_parameter('path_lookahead').value
        self.control_frequency = self.get_parameter('control_frequency').value
        
        # Create publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.path_sub = self.create_subscription(Path, 'planned_path', self.path_callback, 10)
        self.goal_pub = self.create_publisher(PoseStamped, 'goal_pose', 10)
        
        # For getting robot pose
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        
        # Internal state
        self.current_path = None
        self.current_path_index = 0
        self.goal_reached = False
        self.path_following_active = False
        
        # Create a timer for the control loop
        self.control_timer = self.create_timer(1.0/self.control_frequency, self.control_loop)
        
        self.get_logger().info('Robot controller initialized')
    
    def path_callback(self, msg):
        """Handle incoming path message"""
        if not msg.poses:
            self.get_logger().warn('Received empty path')
            return
            
        self.get_logger().info(f'Received path with {len(msg.poses)} waypoints')
        self.current_path = msg
        self.current_path_index = 0
        self.path_following_active = True
        self.goal_reached = False
    
    def set_goal(self, x, y):
        """Set a new goal for the robot"""
        # Create and publish goal message
        goal_msg = PoseStamped()
        goal_msg.header.frame_id = 'map'
        goal_msg.header.stamp = self.get_clock().now().to_msg()
        
        goal_msg.pose.position.x = x
        goal_msg.pose.position.y = y
        goal_msg.pose.position.z = 0.0
        
        goal_msg.pose.orientation.w = 1.0
        
        self.goal_pub.publish(goal_msg)
        self.get_logger().info(f'New goal set at ({x}, {y})')
    
    def get_robot_pose(self):
        """Get the current robot pose from TF"""
        try:
            # Get transform from map to base_link
            transform = self.tf_buffer.lookup_transform(
                'map',
                'base_link',
                rclpy.time.Time()
            )
            
            # Extract position and rotation
            x = transform.transform.translation.x
            y = transform.transform.translation.y
            
            # Get yaw from quaternion
            q = transform.transform.rotation
            _, _, yaw = self.euler_from_quaternion(q.x, q.y, q.z, q.w)
            
            return x, y, yaw
            
        except TransformException as ex:
            self.get_logger().warn(f'Could not get robot pose: {ex}')
            return None
    
    def euler_from_quaternion(self, x, y, z, w):
        """Convert quaternion to Euler angles"""
        # Roll (x-axis rotation)
        sinr_cosp = 2 * (w * x + y * z)
        cosr_cosp = 1 - 2 * (x * x + y * y)
        roll = math.atan2(sinr_cosp, cosr_cosp)
        
        # Pitch (y-axis rotation)
        sinp = 2 * (w * y - z * x)
        if abs(sinp) >= 1:
            pitch = math.copysign(math.pi / 2, sinp)  # Use 90 degrees if out of range
        else:
            pitch = math.asin(sinp)
            
        # Yaw (z-axis rotation)
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        yaw = math.atan2(siny_cosp, cosy_cosp)
        
        return roll, pitch, yaw
    
    def control_loop(self):
        """Main control loop for path following"""
        if not self.path_following_active or not self.current_path:
            # No path to follow
            self.stop_robot()
            return
            
        # Get current robot pose
        pose = self.get_robot_pose()
        if pose is None:
            # Can't get pose, stop for safety
            self.stop_robot()
            return
            
        robot_x, robot_y, robot_yaw = pose
        
        # Check if we've reached the final goal
        if self.current_path_index >= len(self.current_path.poses) - 1:
            # We're targeting the final waypoint
            goal_pose = self.current_path.poses[-1].pose.position
            distance_to_goal = self.distance(robot_x, robot_y, goal_pose.x, goal_pose.y)
            
            if distance_to_goal < self.goal_tolerance:
                self.get_logger().info('Goal reached!')
                self.path_following_active = False
                self.goal_reached = True
                self.stop_robot()
                return
        
        # Determine target point on path
        target_idx = min(
            self.current_path_index + self.path_lookahead,
            len(self.current_path.poses) - 1
        )
        
        target_pose = self.current_path.poses[target_idx].pose.position
        
        # Calculate distance to current target waypoint
        waypoint_pose = self.current_path.poses[self.current_path_index].pose.position
        distance_to_waypoint = self.distance(
            robot_x, robot_y, 
            waypoint_pose.x, waypoint_pose.y
        )
        
        # Move to next waypoint if close enough
        if distance_to_waypoint < self.goal_tolerance and self.current_path_index < len(self.current_path.poses) - 1:
            self.current_path_index += 1
            self.get_logger().debug(f'Moving to waypoint {self.current_path_index}')
            return
        
        # Calculate control inputs
        dx = target_pose.x - robot_x
        dy = target_pose.y - robot_y
        
        # Calculate target heading
        target_heading = math.atan2(dy, dx)
        
        # Calculate heading error (between -pi and pi)
        heading_error = target_heading - robot_yaw
        while heading_error > math.pi:
            heading_error -= 2 * math.pi
        while heading_error < -math.pi:
            heading_error += 2 * math.pi
            
        # Calculate distance
        distance = math.sqrt(dx*dx + dy*dy)
        
        # Generate control commands
        cmd = Twist()
        
        # Angular velocity proportional to heading error
        cmd.angular.z = self.max_angular_speed * (heading_error / math.pi)
        
        # Linear velocity proportional to distance but reduced when turning
        # This makes the robot slow down for sharp turns
        turning_factor = 1.0 - min(1.0, abs(heading_error) / (math.pi/2))
        cmd.linear.x = min(self.max_linear_speed, 0.5 * distance) * turning_factor
        
        # Publish command
        self.cmd_vel_pub.publish(cmd)
        
        if target_idx > self.current_path_index:
            self.get_logger().debug(f'Following path: targeting point {target_idx}, ' +
                           f'current waypoint: {self.current_path_index}')
    
    def stop_robot(self):
        """Stop the robot by sending zero velocity"""
        cmd = Twist()
        self.cmd_vel_pub.publish(cmd)
    
    def distance(self, x1, y1, x2, y2):
        """Calculate Euclidean distance between two points"""
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)


def main(args=None):
    """Main function"""
    print("Robot controller for Dijkstra path following")
    print("Note: This is a template for ROS2 integration.")
    print("To run this, you need a proper ROS2 workspace setup.")
    print("The following code demonstrates how it would be run:")
    
    print("\n--- Robot Controller Code ---")
    print("rclpy.init(args=args)")
    print("node = RobotController()")
    print("rclpy.spin(node)")
    print("node.destroy_node()")
    print("rclpy.shutdown()")
    print("---------------------------\n")
    
    print("\nExample usage:")
    print("1. Start the ROS2 system and simulation")
    print("2. Set a goal for the robot: ros2 topic pub -1 /goal_pose geometry_msgs/PoseStamped \"...\"")
    print("3. The path planner will generate a path using Dijkstra's algorithm")
    print("4. The controller will make the robot follow the path")


if __name__ == "__main__":
    main()
